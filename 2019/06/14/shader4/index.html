<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>卡通渲染尝试 | Codemoph</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="（保密原因省略了一些截图）参考图分析最近在看进击的巨人动画，尝试做一下这个风格的卡通渲染。这篇文章记录了各种波折的过程，所以会有点啰嗦~首先截了一张有代表性的参考图：概括一下这个风格：色块是硬边，且分为两类第一类：原色与暗色diffuse亮部是原色（颜色贴图的颜色）diffuse的暗部+阴影是暗色（原色的一个深色调）第二类：有边缘光与无边缘光两类颜色做了某种混合之后，最后总共会出现四种颜色：没有边"><meta name="keywords" content="Shader"><meta property="og:type" content="article"><meta property="og:title" content="卡通渲染尝试"><meta property="og:url" content="https://jinnm.github.io/2019/06/14/shader4/index.html"><meta property="og:site_name" content="Codemoph"><meta property="og:description" content="（保密原因省略了一些截图）参考图分析最近在看进击的巨人动画，尝试做一下这个风格的卡通渲染。这篇文章记录了各种波折的过程，所以会有点啰嗦~首先截了一张有代表性的参考图：概括一下这个风格：色块是硬边，且分为两类第一类：原色与暗色diffuse亮部是原色（颜色贴图的颜色）diffuse的暗部+阴影是暗色（原色的一个深色调）第二类：有边缘光与无边缘光两类颜色做了某种混合之后，最后总共会出现四种颜色：没有边"><meta property="og:locale" content="en"><meta property="og:image" content="http://ww1.sinaimg.cn/large/006tNc79ly1g414si1yn4j30hv0cs4az.jpg"><meta property="og:image" content="http://ww3.sinaimg.cn/large/006tNc79gy1g49x5ttjktj30ci0irq4l.jpg"><meta property="og:image" content="http://ww3.sinaimg.cn/large/006tNc79ly1g4150nj4zaj30b40aowed.jpg"><meta property="og:image" content="http://ww2.sinaimg.cn/large/006tNc79gy1g49x5tqhz4j312e0u0e81.jpg"><meta property="og:image" content="http://ww1.sinaimg.cn/large/006tNc79ly1g41535fh1wj30a30ai3yj.jpg"><meta property="og:image" content="http://ww4.sinaimg.cn/large/006tNc79ly1g415c66uq3j308f09mmz3.jpg"><meta property="og:image" content="http://ww2.sinaimg.cn/large/006tNc79gy1g41ockfn6ij30fe0kgte8.jpg"><meta property="og:updated_time" content="2019-08-05T09:23:40.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="卡通渲染尝试"><meta name="twitter:description" content="（保密原因省略了一些截图）参考图分析最近在看进击的巨人动画，尝试做一下这个风格的卡通渲染。这篇文章记录了各种波折的过程，所以会有点啰嗦~首先截了一张有代表性的参考图：概括一下这个风格：色块是硬边，且分为两类第一类：原色与暗色diffuse亮部是原色（颜色贴图的颜色）diffuse的暗部+阴影是暗色（原色的一个深色调）第二类：有边缘光与无边缘光两类颜色做了某种混合之后，最后总共会出现四种颜色：没有边"><meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006tNc79ly1g414si1yn4j30hv0cs4az.jpg"><link rel="icon" href="/favicon.png"><link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700" rel="stylesheet"><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"></head><body><div class="site-wrapper"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">C </span><span class="w">o </span><span class="b">d </span><span class="w">e </span><span class="b">m </span><span class="b">o </span><span class="w">p </span><span class="b">h </span></a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-shader4" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">卡通渲染尝试</h1><div class="article-meta">Posted on <time class="article-time" datetime="2019-06-13T16:00:46.000Z" itemprop="datePublished">Jun 14, 2019</time></div></header><div class="article-entry" itemprop="articleBody"><p>（保密原因省略了一些截图）</p><h3 id="参考图分析"><a href="#参考图分析" class="headerlink" title="参考图分析"></a>参考图分析</h3><p>最近在看进击的巨人动画，尝试做一下这个风格的卡通渲染。这篇文章记录了各种波折的过程，所以会有点啰嗦~</p><p>首先截了一张有代表性的参考图：<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g414si1yn4j30hv0cs4az.jpg" alt></p><p>概括一下这个风格：</p><h5 id="色块"><a href="#色块" class="headerlink" title="色块"></a>色块</h5><p>是硬边，且分为两类</p><ul><li>第一类：原色与暗色<ul><li>diffuse亮部是原色（颜色贴图的颜色）</li><li>diffuse的暗部+阴影是暗色（原色的一个深色调）</li></ul></li><li>第二类：有边缘光与无边缘光</li></ul><p>两类颜色做了某种混合之后，最后总共会出现四种颜色：没有边缘光的亮部和暗部、有边缘光的亮部和暗部</p><h5 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h5><ul><li>大部分是粗细均匀的黑色描边</li><li>头发处是描边较细，颜色是头发颜色的加深</li></ul><h5 id="各向异性高光"><a href="#各向异性高光" class="headerlink" title="各向异性高光"></a>各向异性高光</h5><ul><li>头发高光，也是硬边</li><li>还有各向异性的边缘光</li></ul><h5 id="排线"><a href="#排线" class="headerlink" title="排线"></a>排线</h5><ul><li>某些比较重的阴影处，如眉毛下方</li></ul><h3 id="方案构思"><a href="#方案构思" class="headerlink" title="方案构思"></a>方案构思</h3><h5 id="描边-1"><a href="#描边-1" class="headerlink" title="描边"></a>描边</h5><p>先用backface的方法看看，针对表现出来的缺陷想办法改善。</p><h5 id="是否用ramp图做映射"><a href="#是否用ramp图做映射" class="headerlink" title="是否用ramp图做映射"></a>是否用ramp图做映射</h5><p>我一开始没有考虑用ramp图去映射不同色块颜色，因为感觉使用贴图的话，一方面增加包体大小且采样降低效率，另一方面感觉不方便调整，比如想改颜色或者调整边缘柔和程度都要重新导出一张贴图。但是了解过后，发现美术更习惯于在PS中画，在引擎中调整的体验并不好。这里打算先不用ramp写shader，之后再根据实际情况调整，加上ramp图或者在Unity中做个工具。</p><h5 id="暗部颜色的选取"><a href="#暗部颜色的选取" class="headerlink" title="暗部颜色的选取"></a>暗部颜色的选取</h5><p>因为暗部颜色是原色基础上的一种加暗，和原贴图上图案的颜色都有关系，所以应该在原色基础上乘一个灰色，如果希望这个颜色偏冷，那么乘一个偏蓝色的灰色，而不是直接给出一个暗部颜色。</p><h5 id="边缘光强度的衡量"><a href="#边缘光强度的衡量" class="headerlink" title="边缘光强度的衡量"></a>边缘光强度的衡量</h5><p>首先肯定需要用到dot(Normal, View)，另外亮部比暗部更容易有边缘光，所以采用(1 - NdV)*NdL。</p><p>最后根据这个方案写Shader，关键代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//边缘光</span><br><span class="line">float rim = (1.0 - NdV) * NdL;</span><br><span class="line">//暗部和阴影</span><br><span class="line">fixed shadow_atten = SHADOW_ATTENUATION(i);</span><br><span class="line">float gray = saturate(NdL * shadow_atten);</span><br><span class="line">//_StN和_NtR是区分不同色块的参数，调节这两个值可以扩大或缩小暗部和边缘光的范围</span><br><span class="line">fixed4 shadowCol = step(gray, _StN) * _ShadowColor;</span><br><span class="line">fixed4 albedoCol = step(_StN, gray) * fixed4(1,1,1,1);</span><br><span class="line">fixed4 rimCol = step(_NtR, saturate(rim)) * _LightColor0 * _RimPower;  //rimpower调节亮度大小</span><br><span class="line">return (shadowCol + albedoCol + rimCol) * albedo;</span><br></pre></td></tr></table></figure><p>结果是这个样子，发现锯齿比较严重<br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g49x5ttjktj30ci0irq4l.jpg" alt></p><h3 id="改善锯齿"><a href="#改善锯齿" class="headerlink" title="改善锯齿"></a>改善锯齿</h3><p>思考原因，应该是因为使用step，使得颜色发生突变。比如我在ps中画个黑色的圆<br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4150nj4zaj30b40aowed.jpg" alt></p><p>可以发现像素点中不止是黑色和白色，还有几种灰色，这些色块使得锯齿感减弱。而使用step的方法，就使得颜色非黑即白，不存在灰色，那么锯齿感就比较重。</p><p>于是使用smoothstep，将smooth的区间调到很小，既有硬边的感觉，锯齿感又比较弱。<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g49x5tqhz4j312e0u0e81.jpg" alt></p><h3 id="奇怪的边缘光形状"><a href="#奇怪的边缘光形状" class="headerlink" title="奇怪的边缘光形状"></a>奇怪的边缘光形状</h3><p>看实际模型上的效果不太明显，看材质球能发现边缘光似乎怪怪的<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g41535fh1wj30a30ai3yj.jpg" alt></p><p>边缘光的宽度在暗部的减弱感觉非常不自然，似乎需要调节一下rim = (1.0 - NdV) * NdL这个算法，于是接下来就为数学头秃了一段时间……最后忍不住上网看看别人的边缘光算法。</p><h3 id="修改边缘光形状"><a href="#修改边缘光形状" class="headerlink" title="修改边缘光形状"></a>修改边缘光形状</h3><p>网上搜索时看到一篇论文，对我有非常多的启发和帮助。<br><a href="https://hal.inria.fr/inria-00362888/document/" target="_blank" rel="noopener">Pascal Barla, Joëlle Thollot, Lee Markosian. X-Toon: An extended toon shader</a></p><p>我们平常所见的ramp图，都是一维的，uv中只有一个轴用到，这篇论文中，把我们前面提到的两类颜色分别放在贴图的两个维度，u轴映射diffuse（NdL），v轴映射边缘光（NdV）<br><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g415c66uq3j308f09mmz3.jpg" alt></p><p>我们前面提到的暗部高光区域较小，也直接可以通过这张ramp图来体现，通过这张图，对边缘光的控制更加精确。</p><p>尝试了一下红色ramp图的边缘光曲线，效果见下图，左边是smoothstep，右边是二维ramp图，可以发现亮部的边缘光区域大小相同，但是暗部的边缘光区域明显变得自然了，尤其可以看布料顶端，另外材质球上的表现也变自然了。<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g41ockfn6ij30fe0kgte8.jpg" alt></p><p>这里出现的颜色都是贴图上直接采样得到的，但是由于ramp图的颜色还需要跟一张颜色贴图相乘来获取图案信息，而亮部不可能通过两个颜色相乘出来，所以只好将边缘光的部分画在a通道中，暂时没想到更优雅的办法。</p><p>在人物模型上试验一下ramp和albedo图的结合，将边缘光区域大小调节的差不多，差别比较大的是脖子部分，左边图采用用来的做法脖子左右的边缘光显得比较怪异，新的做法就没有这个问题。<br>（截图待补充）</p><h3 id="头发的描边"><a href="#头发的描边" class="headerlink" title="头发的描边"></a>头发的描边</h3><p>前面的描边都采用backface的方法，在这个模型和这个描边粗细的情况下看起来问题不大，但是到了头发上，问题就变明显了<br>可以看到由于发尾比较尖细，描边断开的情况特别明显。先尝试了一下用边缘光的方法做描边：</p><p>可以发现描边粗细不均匀，很多应该有描边的地方没有，还在一些奇怪的地方出现深色。于是尝试将所有发尾顶点的顶点色改成黑色，并将面片外扩距离乘上顶点色，使得发尾强行并起来，得到了这样的效果：</p><p>效果比起前两个好了许多，就是增加了美术的工作量。</p><h3 id="头发高光"><a href="#头发高光" class="headerlink" title="头发高光"></a>头发高光</h3><p>取binormal（发根到发尾），用一张noise图根据法线方向做偏移，偏移后的binormal和高光的关联公式是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fixed hairspec(float3 T, float3 halfDir)</span><br><span class="line">&#123;</span><br><span class="line">    float TdH = dot(T, halfDir); //这里是钝角，不要随手saturate</span><br><span class="line">    float sqrtTdH = sqrt(1 - TdH * TdH);</span><br><span class="line">    float atten = smoothstep(-1, 0, TdH);</span><br><span class="line">    return atten * pow(sqrtTdH, _Glossness * 64.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外有参数NoiseIntensityX和NoiseIntensityY，前者调解抖动波纹的密集稀疏，后者调节抖动幅度。Brightness调节高光亮度，Offset可以偏移高光位置。</p><p>效果是这样，问题在于高光的边缘比较粗糙，而材质球上的预览效果则没有这种问题，看起来精度比较高，几乎是和参考图一样的效果，猜测是因为模型精度低还没用法线贴图的原因。</p></div><div class="article-tags"><a class="tag-link" href="/tagsfol/Shader/">Shader</a></div></article><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div class="search"><form name="searchform" id="searchform" class="u-search-form"><input type="text" id="searchinput" class="u-search-input st-default-search-input" data-list-highlight="true" data-list-value-completion="true" placeholder="Looking for something?"> <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit"><span class="icon icon-search"></span></button></form></div><div>&copy; <a href="https://jinnm.github.io">Codemoph</a> Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div><div>Powered by <a href="https://hexo.io/" rel="external">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></div><div class="site-sidebar"><div class="sidebar-switch clearfix" style="display:none"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-toc" style="display:none"><div class="no-index">No Index</div></div><div class="site-bio show" style="display:block"><div class="about-me clearfix"><div class="avatar"><img src="/img/avatar.png"></div><div class="info"><a class="name dark-btn" href="/2018/04/29/AboutMe/">Jinnm</a></div><div class="info"><span class="item desc"></span></div></div><div class="social clearfix"></div><div class="shortcuts clearfix"><div class="bk"><a href="#header" class="dark-btn window-nav"><span class="icon icon-chevron-thin-up"></span> <span class="text">Back to Top</span></a></div><div class="bk"><a href="#footer" class="dark-btn window-nav"><span class="icon icon-chevron-thin-down"></span> <span class="text">Go to Bottom</span></a></div></div></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo"</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>document.getElementById("loading-bar").style.width="100%"</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>