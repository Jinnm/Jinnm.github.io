<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>移动端丧尸枪击受伤效果 | Codemoph</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="参考了这个插件的大致实现思路，自己做的效果和它视频中展示的也是差不多的。但是它使用了compute buffer，这是移动端不支持的，这里做了比较大的改动。原理简介1、美术分别制作起点mesh和终点mesh，起点mesh拥有两套uv，一套是自己的uv，一套是和终点mesh对应顶点在相同uv位置的uv（找对应点是根据uv距离最近点来判断的）2、实际使用起点的mesh，根据那套用来对应的uv，按顶点i"><meta name="keywords" content="Shader"><meta property="og:type" content="article"><meta property="og:title" content="移动端丧尸枪击受伤效果"><meta property="og:url" content="https://jinnm.github.io/2019/07/27/MeshTransformation/index.html"><meta property="og:site_name" content="Codemoph"><meta property="og:description" content="参考了这个插件的大致实现思路，自己做的效果和它视频中展示的也是差不多的。但是它使用了compute buffer，这是移动端不支持的，这里做了比较大的改动。原理简介1、美术分别制作起点mesh和终点mesh，起点mesh拥有两套uv，一套是自己的uv，一套是和终点mesh对应顶点在相同uv位置的uv（找对应点是根据uv距离最近点来判断的）2、实际使用起点的mesh，根据那套用来对应的uv，按顶点i"><meta property="og:locale" content="en"><meta property="og:image" content="http://ww1.sinaimg.cn/large/006tNc79gy1g5epl2h1tej315h0u0dtj.jpg"><meta property="og:image" content="http://ww3.sinaimg.cn/large/006tNc79gy1g5epl2bmlbj31000u0gvx.jpg"><meta property="og:image" content="http://ww4.sinaimg.cn/large/006tNc79gy1g5epl25s0mj312e0u01kx.jpg"><meta property="og:image" content="http://ww3.sinaimg.cn/large/006tNc79gy1g5epl1zhefj30ge09ote8.jpg"><meta property="og:image" content="http://ww2.sinaimg.cn/large/006tNc79gy1g5epl1w3hpj30q50cuqbw.jpg"><meta property="og:image" content="http://ww1.sinaimg.cn/large/006tNc79gy1g5epmy5y0sj30fy0fxq55.jpg"><meta property="og:image" content="http://ww3.sinaimg.cn/large/006tNc79gy1g5epmy2ygmj30fx0fz3zu.jpg"><meta property="og:image" content="http://ww4.sinaimg.cn/large/006tNc79gy1g5epmy0mx7j30fz0fy0uy.jpg"><meta property="og:image" content="http://ww1.sinaimg.cn/large/006tNc79gy1g5epmxty14j30zi0h4gsu.jpg"><meta property="og:image" content="http://ww2.sinaimg.cn/large/006tNc79gy1g5epmxoxz3j30cp0gm78g.jpg"><meta property="og:image" content="http://ww4.sinaimg.cn/large/006tNc79gy1g5eppwo964j30cn0gxjvj.jpg"><meta property="og:image" content="http://ww4.sinaimg.cn/large/006tNc79gy1g5ept0sm7xj30jq0sa7eh.jpg"><meta property="og:image" content="http://ww2.sinaimg.cn/large/006tNc79gy1g5eppwk7wgj31pi0eetdm.jpg"><meta property="og:image" content="http://ww2.sinaimg.cn/large/006tNc79gy1g5eppwf089j31p80ek793.jpg"><meta property="og:image" content="http://ww3.sinaimg.cn/large/006tNc79gy1g5eppw6ytkj31pa0eotdj.jpg"><meta property="og:updated_time" content="2019-07-27T13:25:32.369Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="移动端丧尸枪击受伤效果"><meta name="twitter:description" content="参考了这个插件的大致实现思路，自己做的效果和它视频中展示的也是差不多的。但是它使用了compute buffer，这是移动端不支持的，这里做了比较大的改动。原理简介1、美术分别制作起点mesh和终点mesh，起点mesh拥有两套uv，一套是自己的uv，一套是和终点mesh对应顶点在相同uv位置的uv（找对应点是根据uv距离最近点来判断的）2、实际使用起点的mesh，根据那套用来对应的uv，按顶点i"><meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006tNc79gy1g5epl2h1tej315h0u0dtj.jpg"><link rel="icon" href="/favicon.png"><link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700" rel="stylesheet"><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"></head><body><div class="site-wrapper"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">C </span><span class="w">o </span><span class="b">d </span><span class="w">e </span><span class="b">m </span><span class="b">o </span><span class="w">p </span><span class="b">h </span></a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-MeshTransformation" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">移动端丧尸枪击受伤效果</h1><div class="article-meta">Posted on <time class="article-time" datetime="2019-07-27T13:04:08.000Z" itemprop="datePublished">Jul 27, 2019</time></div></header><div class="article-entry" itemprop="articleBody"><p>参考了这个<a href="https://assetstore.unity.com/packages/tools/animation/mesh-transformation-120144" target="_blank" rel="noopener">插件</a>的大致实现思路，自己做的效果和它视频中展示的也是差不多的。但是它使用了compute buffer，这是移动端不支持的，这里做了比较大的改动。</p><h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>1、美术分别制作起点mesh和终点mesh，起点mesh拥有两套uv，一套是自己的uv，一套是和终点mesh对应顶点在相同uv位置的uv（找对应点是根据uv距离最近点来判断的）<br>2、实际使用起点的mesh，根据那套用来对应的uv，按顶点id顺序，将终点mesh对应的顶点坐标和顶点法线传入shader<br>3、在起点mesh的shader中做lerp，这样就可以根据一个参数，做起点终点间mesh的morph</p><p>枪击效果：点击位置发射射线和mesh碰撞体求交，返回相交位置的世界坐标，将多个枪击点的世界坐标传入shader中，shader遍历每个枪击点，根据它与当前顶点的距离，迭代用来做morphing的参数，使得离枪击位置越近的点，越接近终点mesh。</p><p>下图分别为起点mesh和终点mesh的例子<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5epl2h1tej315h0u0dtj.jpg" alt><br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5epl2bmlbj31000u0gvx.jpg" alt></p><p>不使用终点mesh法线的话，会对凹陷部位的效果有严重影响<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5epl25s0mj312e0u01kx.jpg" alt></p><h3 id="关键实现"><a href="#关键实现" class="headerlink" title="关键实现"></a>关键实现</h3><h5 id="美术资源制作"><a href="#美术资源制作" class="headerlink" title="美术资源制作"></a>美术资源制作</h5><p>制作流程建议：（以断手为例）<br>1、制作正常状态mesh，如完整的手，展好uv<br>2、制作非常态mesh时，复制一份正常态，对其进行变形，如把手指缩进去，顶点数量不超过65536（法线贴图存放限制）<br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5epl1zhefj30ge09ote8.jpg" alt></p><p>3、调整并确定uv的对应关系，如原来手指上的点的uv区域，对应变形后的顶点区域。不用一一对应，只是一小片一小片区域对应的话，也能达到需要的效果。为了这一步方便，所以第二步时，尽量将顶点按照变形的规律移动，而且先移动好位置，再增减顶点。<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5epl1w3hpj30q50cuqbw.jpg" alt></p><p>4、选用非常态作为起点mesh展一套uv，放到uv0，这个uv就按普通情况展，不用考虑和另一个mesh的对应关系，之前的那套放到uv1<br>（让最后使用的变化反向是很方便的，但是使用非常态mesh做起点可以省一套uv）<br>下面分别是断手两个mesh的三套uv<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5epmy5y0sj30fy0fxq55.jpg" alt><br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5epmy2ygmj30fx0fz3zu.jpg" alt><br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5epmy0mx7j30fz0fy0uy.jpg" alt></p><p>5、将两个mesh放到工具中（目前做的工具在unity上），生成一个新的起点mesh和一张法线图。<br>6、还是在这个工具中，滑动变形滑条，看看顶点变形有没有问题，有问题的话要重新调整做对应关系的那张uv，如果没有问题的话就可以导出生成新mesh和法线图了<br>7、分别以两个mesh的uv0制作贴图<br>8、最后的提交资源是</p><ul><li>工具导出的mesh：长成非常态mesh的样子，有顶点色和两套uv，uv0是自己的，uv1是和正常态的对应uv</li><li>工具导出的法线图：尺寸64*64，下方有很多彩色的像素点</li><li>两个mesh的两套贴图，都是基于自己的uv0<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5epmxty14j30zi0h4gsu.jpg" alt></li></ul><h5 id="将终点mesh的信息传入起点mesh的shader中。"><a href="#将终点mesh的信息传入起点mesh的shader中。" class="headerlink" title="将终点mesh的信息传入起点mesh的shader中。"></a>将终点mesh的信息传入起点mesh的shader中。</h5><p>也就是将终点mesh的顶点坐标和法线传入起点mesh的shader中，插件原本使用的是compute buffer，但是移动端不能使用，所以就将信息写入贴图。</p><p><strong>方案1：</strong>按照顶点id顺序，在动态贴图中写入顶点坐标和法线<br>内存中的贴图可以直接写入顶点坐标，不需要归一化，这个方法在真机上可能会有采样精度的问题，因为数据点密集排列而且相邻像素中存放的顶点位置可能是距离非常远的点。不过我的测试机iphone6s没有问题。</p><p><strong>方案2：</strong>提前烘好贴图<br>因为这个效果原本就已经很费，所以希望尽量减少消耗。提前烘的话就需要写入(0,1)的值，就需要归一化顶点坐标，尝试了一下精度问题还是有点可怕的<br>这个是用没有手指的mesh，在shader中把有手指mesh的顶点赋给它出来的效果<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5epmxoxz3j30cp0gm78g.jpg" alt></p><p><strong>方案3：</strong>顶点位置存在顶点色<br>因为提前烘法线图没有归一化后的精度问题，所以可以把终点mesh的顶点坐标存在顶点色中，用贴图存法线，试了一下效果非常好<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5eppwo964j30cn0gxjvj.jpg" alt></p><h5 id="射击效果"><a href="#射击效果" class="headerlink" title="射击效果"></a>射击效果</h5><p>传射击位置只能通过动态贴图了，不过可以输入一张很小的，因为玩家射击的次数比较有限</p><p>传递到shader后，遍历每个射击点，对做morphing的参数迭代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float p = 0;</span><br><span class="line">for (int ii = 0;ii &lt; _pointsLength; ii++) &#123;</span><br><span class="line">    //计算采样uv位置</span><br><span class="line">    float4 uvInBuffer = float4(</span><br><span class="line">        (ii % _ShootPointsSize + 0.5) / _ShootPointsSize*1.0,</span><br><span class="line">        (ii / _ShootPointsSize + 0.5) / _ShootPointsSize*1.0, 0, 0);</span><br><span class="line">    //采样得到第i个射击点</span><br><span class="line">    float3 points_i = tex2Dlod(_points, uvInBuffer).rgb;</span><br><span class="line">    //大致的p的计算方法</span><br><span class="line">    p = saturate(p += saturate((distance(worldPos, points_i) - HoleSize) * HoleIndensity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际p的计算方法更加细致，比如手臂处，可能打一枪就整个断了，最好影响的顶点范围大一些，而胸腔之类的影响区域比较小，被枪击时不会影响整个形状，所以使用一张mask，使得不同部位的被射击的效果不同。</p><h3 id="真机测试"><a href="#真机测试" class="headerlink" title="真机测试"></a>真机测试</h3><p>测试机为iPhone6s，测试时场景为天空盒和一个测试模型，影响性能的地方主要在射击的次数，分别在0次射击，5次射击，10次射击时抓帧，绘制时间分别为3.99ms，6.00ms，7.48ms</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5ept0sm7xj30jq0sa7eh.jpg" alt><br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5eppwk7wgj31pi0eetdm.jpg" alt><br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5eppwf089j31p80ek793.jpg" alt><br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5eppw6ytkj31pa0eotdj.jpg" alt></p></div><div class="article-tags"><a class="tag-link" href="/tagsfol/Shader/">Shader</a></div></article><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div class="search"><form name="searchform" id="searchform" class="u-search-form"><input type="text" id="searchinput" class="u-search-input st-default-search-input" data-list-highlight="true" data-list-value-completion="true" placeholder="Looking for something?"> <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit"><span class="icon icon-search"></span></button></form></div><div>&copy; <a href="https://jinnm.github.io">Codemoph</a> Theme by <a href="http://artifact.me/" target="_blank">Art Chen</a>.</div><div>Powered by <a href="https://hexo.io/" rel="external">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></div><div class="site-sidebar"><div class="sidebar-switch clearfix" style="display:none"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-toc" style="display:none"><div class="no-index">No Index</div></div><div class="site-bio show" style="display:block"><div class="about-me clearfix"><div class="avatar"><img src="/img/avatar.png"></div><div class="info"><a class="name dark-btn" href="/2018/04/29/AboutMe/">Jinnm</a></div><div class="info"><span class="item desc"></span></div></div><div class="social clearfix"></div><div class="shortcuts clearfix"><div class="bk"><a href="#header" class="dark-btn window-nav"><span class="icon icon-chevron-thin-up"></span> <span class="text">Back to Top</span></a></div><div class="bk"><a href="#footer" class="dark-btn window-nav"><span class="icon icon-chevron-thin-down"></span> <span class="text">Go to Bottom</span></a></div></div></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo"</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script>document.getElementById("loading-bar").style.width="100%"</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>